{"func_name": "test_non_spawnable.test_scalar", "func_src_before": "    def test_scalar(self):\n        s = np.random.RandomState(0)\n        assert_equal(s.randint(1000), 684)\n        s = np.random.RandomState(4294967295)\n        assert_equal(s.randint(1000), 419)", "func_src_after": "    def test_fillna_scalar(self, data_missing):\n        valid = data_missing[1]\n        result = data_missing.fillna(valid)\n        expected = data_missing.fillna(valid)\n        tm.assert_extension_array_equal(result, expected)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 27, "char_end": 63, "line": "        s = np.random.RandomState(0)"}, {"line_no": 3, "char_start": 64, "char_end": 106, "line": "        assert_equal(s.randint(1000), 684)"}, {"line_no": 4, "char_start": 107, "char_end": 152, "line": "        s = np.random.RandomState(4294967295)"}], "added": [{"line_no": 2, "char_start": 48, "char_end": 79, "line": "        valid = data_missing[1]"}, {"line_no": 3, "char_start": 80, "char_end": 123, "line": "        result = data_missing.fillna(valid)"}, {"line_no": 4, "char_start": 124, "char_end": 169, "line": "        expected = data_missing.fillna(valid)"}]}, "char_changes": {"deleted": [{"char_start": 24, "char_end": 151, "chars": "):\n        s = np.random.RandomState(0)\n        assert_equal(s.randint(1000), 684)\n        s = np.random.RandomState(4294967295"}, {"char_start": 169, "char_end": 194, "chars": "qual(s.randint(1000), 419"}], "added": [{"char_start": 13, "char_end": 20, "chars": "fillna_"}, {"char_start": 31, "char_end": 168, "chars": ", data_missing):\n        valid = data_missing[1]\n        result = data_missing.fillna(valid)\n        expected = data_missing.fillna(valid"}, {"char_start": 178, "char_end": 181, "chars": "tm."}, {"char_start": 189, "char_end": 226, "chars": "xtension_array_equal(result, expected"}]}}
{"func_name": "test_suppress_warnings_forwarding.warn_other_module", "func_src_before": "    def warn_other_module():\n        # Apply along axis is implemented in python; stacklevel=2 means\n        # we end up inside its module, not ours.\n        def warn(arr):\n            warnings.warn(\"Some warning\", stacklevel=2)\n            return arr\n        np.apply_along_axis(warn, 0, [0])", "func_src_after": "def test_deprecations(name):\n    # GH#55139\n    msg = f\"{name} is deprecated.* Use public APIs instead\"\n    with tm.assert_produces_warning(DeprecationWarning, match=msg):\n        getattr(internals, name)\n\n    if name not in [\"NumericBlock\", \"ObjectBlock\"]:\n        # NumericBlock and ObjectBlock are not in the internals.api namespace\n        with tm.assert_produces_warning(DeprecationWarning, match=msg):\n            getattr(api, name)", "line_changes": {"deleted": [{"line_no": 1, "char_start": 1, "char_end": 29, "line": "    def warn_other_module():"}, {"line_no": 2, "char_start": 29, "char_end": 100, "line": "        # Apply along axis is implemented in python; stacklevel=2 means"}, {"line_no": 3, "char_start": 101, "char_end": 149, "line": "        # we end up inside its module, not ours."}, {"line_no": 4, "char_start": 150, "char_end": 172, "line": "        def warn(arr):"}, {"line_no": 7, "char_start": 252, "char_end": 293, "line": "        np.apply_along_axis(warn, 0, [0])"}], "added": [{"line_no": 1, "char_start": 1, "char_end": 29, "line": "def test_deprecations(name):"}, {"line_no": 2, "char_start": 29, "char_end": 43, "line": "    # GH#55139"}, {"line_no": 3, "char_start": 44, "char_end": 103, "line": "    msg = f\"{name} is deprecated.* Use public APIs instead\""}, {"line_no": 4, "char_start": 104, "char_end": 171, "line": "    with tm.assert_produces_warning(DeprecationWarning, match=msg):"}, {"line_no": 5, "char_start": 172, "char_end": 204, "line": "        getattr(internals, name)"}]}, "char_changes": {"deleted": [{"char_start": 0, "char_end": 206, "chars": "    def warn_other_module():\n        # Apply along axis is implemented in python; stacklevel=2 means\n        # we end up inside its module, not ours.\n        def warn(arr):\n            warnings.warn(\"Some w"}, {"char_start": 212, "char_end": 213, "chars": "\""}, {"char_start": 215, "char_end": 228, "chars": "stacklevel=2)"}, {"char_start": 241, "char_end": 242, "chars": "r"}, {"char_start": 244, "char_end": 292, "chars": "urn arr\n        np.apply_along_axis(warn, 0, [0]"}], "added": [{"char_start": 0, "char_end": 388, "chars": "def test_deprecations(name):\n    # GH#55139\n    msg = f\"{name} is deprecated.* Use public APIs instead\"\n    with tm.assert_produces_warning(DeprecationWarning, match=msg):\n        getattr(internals, name)\n\n    if name not in [\"NumericBlock\", \"ObjectBlock\"]:\n        # NumericBlock and ObjectBlock are not in the internals.api namespace\n        with tm.assert_produces_warning(DeprecationW"}, {"char_start": 396, "char_end": 407, "chars": "match=msg):"}, {"char_start": 420, "char_end": 421, "chars": "g"}, {"char_start": 423, "char_end": 437, "chars": "attr(api, name"}]}}
{"func_name": "assert_mask_equal.test_choose", "func_src_before": "    def test_choose(self):\n        # Test choose\n        choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n                   [20, 21, 22, 23], [30, 31, 32, 33]]\n        chosen = choose([2, 3, 1, 0], choices)\n        assert_equal(chosen, array([20, 31, 12, 3]))\n        chosen = choose([2, 4, 1, 0], choices, mode='clip')\n        assert_equal(chosen, array([20, 31, 12, 3]))\n        chosen = choose([2, 4, 1, 0], choices, mode='wrap')\n        assert_equal(chosen, array([20, 1, 12, 3]))\n        # Check with some masked indices\n        indices_ = array([2, 4, 1, 0], mask=[1, 0, 0, 1])\n        chosen = choose(indices_, choices, mode='wrap')\n        assert_equal(chosen, array([99, 1, 12, 99]))\n        assert_equal(chosen.mask, [1, 0, 0, 1])\n        # Check with some masked choices\n        choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1],\n                                       [1, 0, 0, 0], [0, 0, 0, 0]])\n        indices_ = [2, 3, 1, 0]\n        chosen = choose(indices_, choices, mode='wrap')\n        assert_equal(chosen, array([20, 31, 12, 3]))\n        assert_equal(chosen.mask, [1, 0, 0, 1])", "func_src_after": "    def test_fillna_overlap(self):\n        s = SparseArray([1, np.nan, np.nan, 3, np.nan])\n        # filling with existing value doesn't replace existing value with\n        # fill_value, i.e. existing 3 remains in sp_values\n        res = s.fillna(3)\n        exp = np.array([1, 3, 3, 3, 3], dtype=np.float64)\n        tm.assert_numpy_array_equal(res.to_dense(), exp)\n\n        s = SparseArray([1, np.nan, np.nan, 3, np.nan], fill_value=0)\n        res = s.fillna(3)\n        exp = SparseArray([1, 3, 3, 3, 3], fill_value=0, dtype=np.float64)\n        tm.assert_sp_array_equal(res, exp)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 27, "char_end": 48, "line": "        # Test choose"}, {"line_no": 4, "char_start": 100, "char_end": 154, "line": "                   [20, 21, 22, 23], [30, 31, 32, 33]]"}, {"line_no": 5, "char_start": 155, "char_end": 201, "line": "        chosen = choose([2, 3, 1, 0], choices)"}, {"line_no": 6, "char_start": 202, "char_end": 254, "line": "        assert_equal(chosen, array([20, 31, 12, 3]))"}, {"line_no": 7, "char_start": 255, "char_end": 314, "line": "        chosen = choose([2, 4, 1, 0], choices, mode='clip')"}, {"line_no": 8, "char_start": 315, "char_end": 367, "line": "        assert_equal(chosen, array([20, 31, 12, 3]))"}, {"line_no": 9, "char_start": 368, "char_end": 427, "line": "        chosen = choose([2, 4, 1, 0], choices, mode='wrap')"}, {"line_no": 10, "char_start": 428, "char_end": 479, "line": "        assert_equal(chosen, array([20, 1, 12, 3]))"}, {"line_no": 11, "char_start": 480, "char_end": 520, "line": "        # Check with some masked indices"}, {"line_no": 13, "char_start": 579, "char_end": 634, "line": "        chosen = choose(indices_, choices, mode='wrap')"}, {"line_no": 15, "char_start": 688, "char_end": 735, "line": "        assert_equal(chosen.mask, [1, 0, 0, 1])"}, {"line_no": 16, "char_start": 736, "char_end": 776, "line": "        # Check with some masked choices"}, {"line_no": 18, "char_start": 844, "char_end": 911, "line": "                                       [1, 0, 0, 0], [0, 0, 0, 0]])"}, {"line_no": 20, "char_start": 944, "char_end": 999, "line": "        chosen = choose(indices_, choices, mode='wrap')"}, {"line_no": 22, "char_start": 1053, "char_end": 1100, "line": "        assert_equal(chosen.mask, [1, 0, 0, 1])"}], "added": [{"line_no": 2, "char_start": 35, "char_end": 90, "line": "        s = SparseArray([1, np.nan, np.nan, 3, np.nan])"}, {"line_no": 3, "char_start": 91, "char_end": 164, "line": "        # filling with existing value doesn't replace existing value with"}, {"line_no": 4, "char_start": 165, "char_end": 223, "line": "        # fill_value, i.e. existing 3 remains in sp_values"}, {"line_no": 5, "char_start": 224, "char_end": 249, "line": "        res = s.fillna(3)"}, {"line_no": 10, "char_start": 436, "char_end": 461, "line": "        res = s.fillna(3)"}]}, "char_changes": {"deleted": [{"char_start": 13, "char_end": 19, "chars": "choose"}, {"char_start": 35, "char_end": 82, "chars": "# Test choose\n        choices = [[0, 1, 2, 3], "}, {"char_start": 84, "char_end": 85, "chars": "0"}, {"char_start": 87, "char_end": 570, "chars": "11, 12, 13],\n                   [20, 21, 22, 23], [30, 31, 32, 33]]\n        chosen = choose([2, 3, 1, 0], choices)\n        assert_equal(chosen, array([20, 31, 12, 3]))\n        chosen = choose([2, 4, 1, 0], choices, mode='clip')\n        assert_equal(chosen, array([20, 31, 12, 3]))\n        chosen = choose([2, 4, 1, 0], choices, mode='wrap')\n        assert_equal(chosen, array([20, 1, 12, 3]))\n        # Check with some masked indices\n        indices_ = array([2, 4, 1, 0], mask=[1, 0"}, {"char_start": 572, "char_end": 573, "chars": "0"}, {"char_start": 575, "char_end": 633, "chars": "1])\n        chosen = choose(indices_, choices, mode='wrap'"}, {"char_start": 650, "char_end": 821, "chars": "equal(chosen, array([99, 1, 12, 99]))\n        assert_equal(chosen.mask, [1, 0, 0, 1])\n        # Check with some masked choices\n        choices = array(choices, mask=[[0, 0"}, {"char_start": 823, "char_end": 824, "chars": "0"}, {"char_start": 826, "char_end": 933, "chars": "1], [1, 1, 0, 1],\n                                       [1, 0, 0, 0], [0, 0, 0, 0]])\n        indices_ = [2"}, {"char_start": 938, "char_end": 939, "chars": "1"}, {"char_start": 941, "char_end": 998, "chars": "0]\n        chosen = choose(indices_, choices, mode='wrap'"}, {"char_start": 1015, "char_end": 1099, "chars": "equal(chosen, array([20, 31, 12, 3]))\n        assert_equal(chosen.mask, [1, 0, 0, 1]"}], "added": [{"char_start": 13, "char_end": 27, "chars": "fillna_overlap"}, {"char_start": 43, "char_end": 278, "chars": "s = SparseArray([1, np.nan, np.nan, 3, np.nan])\n        # filling with existing value doesn't replace existing value with\n        # fill_value, i.e. existing 3 remains in sp_values\n        res = s.fillna(3)\n        exp = np.array([1, 3"}, {"char_start": 280, "char_end": 281, "chars": "3"}, {"char_start": 283, "char_end": 284, "chars": "3"}, {"char_start": 286, "char_end": 306, "chars": "3], dtype=np.float64"}, {"char_start": 316, "char_end": 319, "chars": "tm."}, {"char_start": 326, "char_end": 408, "chars": "numpy_array_equal(res.to_dense(), exp)\n\n        s = SparseArray([1, np.nan, np.nan"}, {"char_start": 410, "char_end": 411, "chars": "3"}, {"char_start": 413, "char_end": 490, "chars": "np.nan], fill_value=0)\n        res = s.fillna(3)\n        exp = SparseArray([1"}, {"char_start": 495, "char_end": 496, "chars": "3"}, {"char_start": 498, "char_end": 535, "chars": "3, 3], fill_value=0, dtype=np.float64"}, {"char_start": 545, "char_end": 548, "chars": "tm."}, {"char_start": 555, "char_end": 578, "chars": "sp_array_equal(res, exp"}]}}
{"func_name": "test_non_spawnable.test_backwards_compatibility", "func_src_before": "    def test_backwards_compatibility(self):\n        # Make sure we can accept old state tuples that do not have the\n        # cached Gaussian value.\n        old_state = self.state[:-2]\n        x1 = self.prng.standard_normal(size=16)\n        self.prng.set_state(old_state)\n        x2 = self.prng.standard_normal(size=16)\n        self.prng.set_state(self.state)\n        x3 = self.prng.standard_normal(size=16)\n        assert_(np.all(x1 == x2))\n        assert_(np.all(x1 == x3))", "func_src_after": "    def test_take_series(self, ser):\n        indices = [1, 5, -2, 6, 3, -1]\n        out = ser.take(indices)\n        expected = Series(\n            data=ser.values.take(indices),\n            index=ser.index.take(indices),\n            dtype=ser.dtype,\n        )\n        tm.assert_series_equal(out, expected)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 44, "char_end": 115, "line": "        # Make sure we can accept old state tuples that do not have the"}, {"line_no": 3, "char_start": 116, "char_end": 148, "line": "        # cached Gaussian value."}, {"line_no": 4, "char_start": 149, "char_end": 184, "line": "        old_state = self.state[:-2]"}, {"line_no": 6, "char_start": 233, "char_end": 271, "line": "        self.prng.set_state(old_state)"}, {"line_no": 7, "char_start": 272, "char_end": 319, "line": "        x2 = self.prng.standard_normal(size=16)"}, {"line_no": 9, "char_start": 360, "char_end": 407, "line": "        x3 = self.prng.standard_normal(size=16)"}, {"line_no": 10, "char_start": 408, "char_end": 441, "line": "        assert_(np.all(x1 == x2))"}], "added": [{"line_no": 2, "char_start": 37, "char_end": 75, "line": "        indices = [1, 5, -2, 6, 3, -1]"}, {"line_no": 3, "char_start": 76, "char_end": 107, "line": "        out = ser.take(indices)"}, {"line_no": 4, "char_start": 108, "char_end": 134, "line": "        expected = Series("}, {"line_no": 7, "char_start": 221, "char_end": 249, "line": "            dtype=ser.dtype,"}, {"line_no": 8, "char_start": 250, "char_end": 259, "line": "        )"}]}, "char_changes": {"deleted": [{"char_start": 13, "char_end": 183, "chars": "backwards_compatibility(self):\n        # Make sure we can accept old state tuples that do not have the\n        # cached Gaussian value.\n        old_state = self.state[:-2"}, {"char_start": 193, "char_end": 195, "chars": "x1"}, {"char_start": 200, "char_end": 343, "chars": "lf.prng.standard_normal(size=16)\n        self.prng.set_state(old_state)\n        x2 = self.prng.standard_normal(size=16)\n        self.prng.set_s"}, {"char_start": 345, "char_end": 346, "chars": "t"}, {"char_start": 348, "char_end": 440, "chars": "self.state)\n        x3 = self.prng.standard_normal(size=16)\n        assert_(np.all(x1 == x2)"}, {"char_start": 457, "char_end": 474, "chars": "(np.all(x1 == x3)"}], "added": [{"char_start": 13, "char_end": 163, "chars": "take_series(self, ser):\n        indices = [1, 5, -2, 6, 3, -1]\n        out = ser.take(indices)\n        expected = Series(\n            data=ser.values."}, {"char_start": 165, "char_end": 166, "chars": "k"}, {"char_start": 168, "char_end": 206, "chars": "indices),\n            index=ser.index."}, {"char_start": 208, "char_end": 209, "chars": "k"}, {"char_start": 211, "char_end": 258, "chars": "indices),\n            dtype=ser.dtype,\n        "}, {"char_start": 268, "char_end": 271, "chars": "tm."}, {"char_start": 278, "char_end": 304, "chars": "series_equal(out, expected"}]}}
{"func_name": "_raise_warning.has_f2py_sources", "func_src_before": "    def has_f2py_sources(self):\n        for source in self.sources:\n            if fortran_pyf_ext_re(source):\n                return True\n        return False", "func_src_after": "    def test_argmax_axis_invalid(self, index):\n        # GH#23081\n        msg = r\"`axis` must be fewer than the number of dimensions \\(1\\)\"\n        with pytest.raises(ValueError, match=msg):\n            index.argmax(axis=1)\n        with pytest.raises(ValueError, match=msg):\n            index.argmin(axis=2)\n        with pytest.raises(ValueError, match=msg):\n            index.min(axis=-2)\n        with pytest.raises(ValueError, match=msg):\n            index.max(axis=-3)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 32, "char_end": 67, "line": "        for source in self.sources:"}, {"line_no": 3, "char_start": 68, "char_end": 110, "line": "            if fortran_pyf_ext_re(source):"}, {"line_no": 4, "char_start": 111, "char_end": 138, "line": "                return True"}, {"line_no": 5, "char_start": 139, "char_end": 159, "line": "        return False"}], "added": [{"line_no": 2, "char_start": 47, "char_end": 65, "line": "        # GH#23081"}, {"line_no": 3, "char_start": 66, "char_end": 139, "line": "        msg = r\"`axis` must be fewer than the number of dimensions \\(1\\)\""}, {"line_no": 4, "char_start": 140, "char_end": 190, "line": "        with pytest.raises(ValueError, match=msg):"}, {"line_no": 5, "char_start": 191, "char_end": 223, "line": "            index.argmax(axis=1)"}, {"line_no": 6, "char_start": 224, "char_end": 274, "line": "        with pytest.raises(ValueError, match=msg):"}, {"line_no": 7, "char_start": 275, "char_end": 307, "line": "            index.argmin(axis=2)"}, {"line_no": 8, "char_start": 308, "char_end": 358, "line": "        with pytest.raises(ValueError, match=msg):"}, {"line_no": 9, "char_start": 359, "char_end": 389, "line": "            index.min(axis=-2)"}, {"line_no": 10, "char_start": 390, "char_end": 440, "line": "        with pytest.raises(ValueError, match=msg):"}, {"line_no": 11, "char_start": 441, "char_end": 471, "line": "            index.max(axis=-3)"}]}, "char_changes": {"deleted": [{"char_start": 8, "char_end": 159, "chars": "has_f2py_sources(self):\n        for source in self.sources:\n            if fortran_pyf_ext_re(source):\n                return True\n        return False"}], "added": [{"char_start": 8, "char_end": 471, "chars": "test_argmax_axis_invalid(self, index):\n        # GH#23081\n        msg = r\"`axis` must be fewer than the number of dimensions \\(1\\)\"\n        with pytest.raises(ValueError, match=msg):\n            index.argmax(axis=1)\n        with pytest.raises(ValueError, match=msg):\n            index.argmin(axis=2)\n        with pytest.raises(ValueError, match=msg):\n            index.min(axis=-2)\n        with pytest.raises(ValueError, match=msg):\n            index.max(axis=-3)"}]}}
{"func_name": "equal", "func_src_before": "def equal(x1, x2):\n    \"\"\"\n    Return (x1 == x2) element-wise.\n\n    Unlike `numpy.equal`, this comparison is performed by first\n    stripping whitespace characters from the end of the string.  This\n    behavior is provided for backward-compatibility with numarray.\n\n    Parameters\n    ----------\n    x1, x2 : array_like of str or unicode\n        Input arrays of the same shape.\n\n    Returns\n    -------\n    out : ndarray\n        Output array of bools.\n\n    See Also\n    --------\n    not_equal, greater_equal, less_equal, greater, less\n    \"\"\"\n    return compare_chararrays(x1, x2, '==', True)", "func_src_after": "def _check_legend_labels(axes, labels=None, visible=True):\n    \"\"\"\n    Check each axes has expected legend labels\n\n    Parameters\n    ----------\n    axes : matplotlib Axes object, or its list-like\n    labels : list-like\n        expected legend labels\n    visible : bool\n        expected legend visibility. labels are checked only when visible is\n        True\n    \"\"\"\n    if visible and (labels is None):\n        raise ValueError(\"labels must be specified when visible is True\")\n    axes = _flatten_visible(axes)\n    for ax in axes:\n        if visible:\n            assert ax.get_legend() is not None\n            _check_text_labels(ax.get_legend().get_texts(), labels)\n        else:\n            assert ax.get_legend() is None", "line_changes": {"deleted": [{"line_no": 2, "char_start": 19, "char_end": 26, "line": "    \"\"\""}, {"line_no": 3, "char_start": 27, "char_end": 62, "line": "    Return (x1 == x2) element-wise."}], "added": [{"line_no": 2, "char_start": 59, "char_end": 66, "line": "    \"\"\""}, {"line_no": 3, "char_start": 67, "char_end": 113, "line": "    Check each axes has expected legend labels"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 592, "chars": "equal(x1, x2):\n    \"\"\"\n    Return (x1 == x2) element-wise.\n\n    Unlike `numpy.equal`, this comparison is performed by first\n    stripping whitespace characters from the end of the string.  This\n    behavior is provided for backward-compatibility with numarray.\n\n    Parameters\n    ----------\n    x1, x2 : array_like of str or unicode\n        Input arrays of the same shape.\n\n    Returns\n    -------\n    out : ndarray\n        Output array of bools.\n\n    See Also\n    --------\n    not_equal, greater_equal, less_equal, greater, less\n    \"\"\"\n    return compare_chararrays(x1, x2, '==', True)"}], "added": [{"char_start": 4, "char_end": 723, "chars": "_check_legend_labels(axes, labels=None, visible=True):\n    \"\"\"\n    Check each axes has expected legend labels\n\n    Parameters\n    ----------\n    axes : matplotlib Axes object, or its list-like\n    labels : list-like\n        expected legend labels\n    visible : bool\n        expected legend visibility. labels are checked only when visible is\n        True\n    \"\"\"\n    if visible and (labels is None):\n        raise ValueError(\"labels must be specified when visible is True\")\n    axes = _flatten_visible(axes)\n    for ax in axes:\n        if visible:\n            assert ax.get_legend() is not None\n            _check_text_labels(ax.get_legend().get_texts(), labels)\n        else:\n            assert ax.get_legend() is None"}]}}
{"func_name": "test_integer_integer_comparison.test_unpickle_dtype_with_object", "func_src_before": "    def test_unpickle_dtype_with_object(self):\n        # Implemented in r2840\n        dt = np.dtype([('x', int), ('y', np.object_), ('z', 'O')])\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            with BytesIO() as f:\n                pickle.dump(dt, f, protocol=proto)\n                f.seek(0)\n                dt_ = pickle.load(f)\n            assert_equal(dt, dt_)", "func_src_after": "    def test_series_named_agg_duplicates_no_raises(self):\n        # GH28426\n        gr = Series([1, 2, 3]).groupby([0, 0, 1])\n        grouped = gr.agg(a=\"sum\", b=\"sum\")\n        expected = DataFrame({\"a\": [3, 3], \"b\": [3, 3]}, index=np.array([0, 1]))\n        tm.assert_frame_equal(expected, grouped)", "line_changes": {"deleted": [{"line_no": 4, "char_start": 145, "char_end": 204, "line": "        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):"}, {"line_no": 5, "char_start": 205, "char_end": 237, "line": "            with BytesIO() as f:"}, {"line_no": 6, "char_start": 238, "char_end": 288, "line": "                pickle.dump(dt, f, protocol=proto)"}, {"line_no": 7, "char_start": 289, "char_end": 314, "line": "                f.seek(0)"}, {"line_no": 8, "char_start": 315, "char_end": 351, "line": "                dt_ = pickle.load(f)"}], "added": [{"line_no": 4, "char_start": 126, "char_end": 168, "line": "        grouped = gr.agg(a=\"sum\", b=\"sum\")"}, {"line_no": 5, "char_start": 169, "char_end": 249, "line": "        expected = DataFrame({\"a\": [3, 3], \"b\": [3, 3]}, index=np.array([0, 1]))"}]}, "char_changes": {"deleted": [{"char_start": 13, "char_end": 39, "chars": "unpickle_dtype_with_object"}, {"char_start": 57, "char_end": 73, "chars": "Implemented in r"}, {"char_start": 76, "char_end": 77, "chars": "0"}, {"char_start": 86, "char_end": 88, "chars": "dt"}, {"char_start": 91, "char_end": 350, "chars": "np.dtype([('x', int), ('y', np.object_), ('z', 'O')])\n        for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n            with BytesIO() as f:\n                pickle.dump(dt, f, protocol=proto)\n                f.seek(0)\n                dt_ = pickle.load(f"}, {"char_start": 360, "char_end": 364, "chars": "    "}, {"char_start": 371, "char_end": 384, "chars": "equal(dt, dt_"}], "added": [{"char_start": 13, "char_end": 50, "chars": "series_named_agg_duplicates_no_raises"}, {"char_start": 68, "char_end": 70, "chars": "GH"}, {"char_start": 73, "char_end": 75, "chars": "26"}, {"char_start": 84, "char_end": 86, "chars": "gr"}, {"char_start": 89, "char_end": 248, "chars": "Series([1, 2, 3]).groupby([0, 0, 1])\n        grouped = gr.agg(a=\"sum\", b=\"sum\")\n        expected = DataFrame({\"a\": [3, 3], \"b\": [3, 3]}, index=np.array([0, 1])"}, {"char_start": 258, "char_end": 261, "chars": "tm."}, {"char_start": 268, "char_end": 297, "chars": "frame_equal(expected, grouped"}]}}
{"func_name": "outmess", "func_src_before": "def outmess(t):\n    if options.get('verbose', 1):\n        sys.stdout.write(t)", "func_src_after": "def test_ensure_timedelta64ns_overflows():\n    arr = np.arange(10).astype(\"m8[Y]\") * 100\n    msg = r\"Cannot convert 300 years to timedelta64\\[ns\\] without overflow\"\n    with pytest.raises(OutOfBoundsTimedelta, match=msg):\n        astype_overflowsafe(arr, dtype=np.dtype(\"m8[ns]\"))", "line_changes": {"deleted": [{"line_no": 2, "char_start": 16, "char_end": 49, "line": "    if options.get('verbose', 1):"}, {"line_no": 3, "char_start": 50, "char_end": 77, "line": "        sys.stdout.write(t)"}], "added": [{"line_no": 2, "char_start": 43, "char_end": 88, "line": "    arr = np.arange(10).astype(\"m8[Y]\") * 100"}, {"line_no": 3, "char_start": 89, "char_end": 164, "line": "    msg = r\"Cannot convert 300 years to timedelta64\\[ns\\] without overflow\""}, {"line_no": 4, "char_start": 165, "char_end": 221, "line": "    with pytest.raises(OutOfBoundsTimedelta, match=msg):"}, {"line_no": 5, "char_start": 222, "char_end": 280, "line": "        astype_overflowsafe(arr, dtype=np.dtype(\"m8[ns]\"))"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 10, "chars": "outmes"}, {"char_start": 12, "char_end": 13, "chars": "t"}, {"char_start": 20, "char_end": 76, "chars": "if options.get('verbose', 1):\n        sys.stdout.write(t"}], "added": [{"char_start": 4, "char_end": 279, "chars": "test_ensure_timedelta64ns_overflows():\n    arr = np.arange(10).astype(\"m8[Y]\") * 100\n    msg = r\"Cannot convert 300 years to timedelta64\\[ns\\] without overflow\"\n    with pytest.raises(OutOfBoundsTimedelta, match=msg):\n        astype_overflowsafe(arr, dtype=np.dtype(\"m8[ns]\")"}]}}
{"func_name": "write_release.testMin", "func_src_before": "    def testMin(self):\n        \"Test min function\"\n        print(self.typeStr, \"... \", file=sys.stderr)\n        min = SuperTensor.__dict__[self.typeStr + \"Min\"]\n        supertensor = [[[[9, 8], [7, 6]], [[5, 4], [3, 2]]], [[[9, 8], [7, 6]], [[5, 4], [3, 2]]]]\n        self.assertEqual(min(supertensor), 2)", "func_src_after": "    def test_constructor_int_dtype_nan(self):\n        # see gh-15187\n        data = [np.nan]\n        expected = Index(data, dtype=np.float64)\n        result = Index(data, dtype=\"float\")\n        tm.assert_index_equal(result, expected)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 23, "char_end": 50, "line": "        \"Test min function\""}, {"line_no": 3, "char_start": 51, "char_end": 103, "line": "        print(self.typeStr, \"... \", file=sys.stderr)"}, {"line_no": 4, "char_start": 104, "char_end": 160, "line": "        min = SuperTensor.__dict__[self.typeStr + \"Min\"]"}], "added": [{"line_no": 2, "char_start": 46, "char_end": 68, "line": "        # see gh-15187"}, {"line_no": 3, "char_start": 69, "char_end": 92, "line": "        data = [np.nan]"}, {"line_no": 4, "char_start": 93, "char_end": 141, "line": "        expected = Index(data, dtype=np.float64)"}, {"line_no": 5, "char_start": 142, "char_end": 185, "line": "        result = Index(data, dtype=\"float\")"}]}, "char_changes": {"deleted": [{"char_start": 12, "char_end": 159, "chars": "Min(self):\n        \"Test min function\"\n        print(self.typeStr, \"... \", file=sys.stderr)\n        min = SuperTensor.__dict__[self.typeStr + \"Min\""}, {"char_start": 169, "char_end": 171, "chars": "su"}, {"char_start": 173, "char_end": 174, "chars": "r"}, {"char_start": 176, "char_end": 259, "chars": "nsor = [[[[9, 8], [7, 6]], [[5, 4], [3, 2]]], [[[9, 8], [7, 6]], [[5, 4], [3, 2]]]]"}, {"char_start": 268, "char_end": 272, "chars": "self"}, {"char_start": 279, "char_end": 291, "chars": "Equal(min(su"}, {"char_start": 293, "char_end": 294, "chars": "r"}, {"char_start": 296, "char_end": 304, "chars": "nsor), 2"}], "added": [{"char_start": 12, "char_end": 185, "chars": "_constructor_int_dtype_nan(self):\n        # see gh-15187\n        data = [np.nan]\n        expected = Index(data, dtype=np.float64)\n        result = Index(data, dtype=\"float\")"}, {"char_start": 194, "char_end": 196, "chars": "tm"}, {"char_start": 203, "char_end": 226, "chars": "_index_equal(result, ex"}, {"char_start": 228, "char_end": 229, "chars": "c"}, {"char_start": 231, "char_end": 232, "chars": "d"}]}}
{"func_name": "test_non_spawnable.test_shuffle_of_array_of_different_length_strings", "func_src_before": "    def test_shuffle_of_array_of_different_length_strings(self):\n        # Test that permuting an array of different length strings\n        # will not cause a segfault on garbage collection\n        # Tests gh-7710\n        random.seed(1234)\n\n        a = np.array(['a', 'a' * 1000])\n\n        for _ in range(100):\n            random.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n        gc.collect()", "func_src_after": "    def test_at_time_nonexistent(self, frame_or_series):\n        # time doesn't exist\n        rng = date_range(\"1/1/2012\", freq=\"23Min\", periods=384)\n        ts = DataFrame(np.random.default_rng(2).standard_normal(len(rng)), rng)\n        ts = tm.get_obj(ts, frame_or_series)\n        rs = ts.at_time(\"16:00\")\n        assert len(rs) == 0", "line_changes": {"deleted": [{"line_no": 3, "char_start": 132, "char_end": 189, "line": "        # will not cause a segfault on garbage collection"}, {"line_no": 4, "char_start": 190, "char_end": 213, "line": "        # Tests gh-7710"}, {"line_no": 5, "char_start": 214, "char_end": 239, "line": "        random.seed(1234)"}, {"line_no": 10, "char_start": 311, "char_end": 340, "line": "            random.shuffle(a)"}], "added": [{"line_no": 2, "char_start": 57, "char_end": 85, "line": "        # time doesn't exist"}, {"line_no": 3, "char_start": 86, "char_end": 149, "line": "        rng = date_range(\"1/1/2012\", freq=\"23Min\", periods=384)"}, {"line_no": 5, "char_start": 230, "char_end": 274, "line": "        ts = tm.get_obj(ts, frame_or_series)"}, {"line_no": 6, "char_start": 275, "char_end": 307, "line": "        rs = ts.at_time(\"16:00\")"}, {"line_no": 7, "char_start": 308, "char_end": 335, "line": "        assert len(rs) == 0"}]}, "char_changes": {"deleted": [{"char_start": 13, "char_end": 49, "chars": "shuffle_of_array_of_different_length"}, {"char_start": 51, "char_end": 52, "chars": "t"}, {"char_start": 54, "char_end": 62, "chars": "ngs(self"}, {"char_start": 75, "char_end": 298, "chars": "Test that permuting an array of different length strings\n        # will not cause a segfault on garbage collection\n        # Tests gh-7710\n        random.seed(1234)\n\n        a = np.array(['a', 'a' * 1000])\n\n        for _ in"}, {"char_start": 300, "char_end": 301, "chars": "a"}, {"char_start": 303, "char_end": 438, "chars": "e(100):\n            random.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n        gc.collect()"}], "added": [{"char_start": 13, "char_end": 224, "chars": "at_time_nonexistent(self, frame_or_series):\n        # time doesn't exist\n        rng = date_range(\"1/1/2012\", freq=\"23Min\", periods=384)\n        ts = DataFrame(np.random.default_rng(2).standard_normal(len(rng)),"}, {"char_start": 228, "char_end": 229, "chars": ")"}, {"char_start": 238, "char_end": 335, "chars": "ts = tm.get_obj(ts, frame_or_series)\n        rs = ts.at_time(\"16:00\")\n        assert len(rs) == 0"}]}}
